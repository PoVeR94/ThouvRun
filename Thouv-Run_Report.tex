\documentclass[11pt,a4paper,french]{article}
\usepackage[utf-8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{amsmath}
\usepackage{babel}
\usepackage{tikz}

% --- CONFIGURATION LISTINGS ---
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    backgroundcolor=\color{gray!10},
    frame=single,
    language=Python
}

% --- EN-TÊTES ET PIEDS ---
\pagestyle{fancy}
\fancyhf{}
\rhead{Thouv'Run - Rapport de Développement}
\lhead{Janvier 2026}
\cfoot{\thepage}

\title{\textbf{Thouv'Run} \\ \Large Un Jeu de Plateforme Multijoueur}
\author{Développeur(s) du Projet}
\date{Janvier 2026}

\begin{document}

\maketitle

\begin{abstract}
\noindent\textbf{Thouv'Run} est un jeu de plateforme dynamique et compétitif développé en \textbf{Python 3.12}. Le joueur incarne Bastien qui se déplace en rollers et doit éviter des obstacles (voitures, camions, policiers) tout en collectant des bonus ("bedos"). Le jeu propose deux interfaces : une version graphique moderne (Pygame) et une version rétro en terminal. Les scores sont synchronisés en ligne via une API Flask et accessibles sur un leaderboard web en temps réel.
\end{abstract}

\newpage
\tableofcontents
\newpage

% ==================== SECTION 1 ====================
\section{Présentation du Projet}

\subsection{Concept et Objectif}

Thouv'Run est un jeu arcade rapide où le joueur doit :
\begin{itemize}
    \item \textbf{Esquiver} trois types d'obstacles : voitures, camions et policiers
    \item \textbf{Courir} le plus loin possible pour maximiser son score
    \item \textbf{Collecter} des bonus appelés "bedos" pour gagner des points
    \item \textbf{Compétitionner} avec d'autres joueurs via un leaderboard en ligne
\end{itemize}

Le titre "Thouv'Run" est une référence ludique : le personnage principal, Bastien Thouverez, fait sa première rentrée avec des rollers le premier jour des cours et découvre qu'il est en retard!

\subsection{Caractéristiques Principales}

\begin{tcolorbox}[colback=blue!5!white, colframe=blue!75!black, title=Fonctionnalités Clés]
\begin{itemize}
    \item[\checkmark] Deux interfaces de jeu : Graphique (Pygame) et Terminal (Curses)
    \item[\checkmark] Deux niveaux de difficulté : NORMALE et DIFFICILE (x1.5 points)
    \item[\checkmark] Synchronisation automatique des scores avec serveur (API Flask)
    \item[\checkmark] Leaderboard web avec recherche, tri et statistiques
    \item[\checkmark] Gestion de la musique et des effets sonores
    \item[\checkmark] Sauvegarde locale (JSON) + serveur de secours
    \item[\checkmark] Support hors-ligne (scores synchro à la reconnexion)
\end{itemize}
\end{tcolorbox}

% ==================== SECTION 2 ====================
\section{Gameplay et Mécanique}

\subsection{Contrôles}

Le joueur contrôle Bastien avec les touches suivantes :

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Touche} & \textbf{Action} & \textbf{Obstacle} \\
\hline
SPACE / FLECHE HAUT & Saut Court & Voiture, Policier \\
Z / W & Saut Long & Camion \\
ESC & Pause / Menu & — \\
R & Redémarrer & Après Game Over \\
F11 & Plein écran & Mode Graphique \\
\hline
\end{tabular}
\end{center}

\subsection{Mécanique de Jeu}

\subsubsection{Génération d'Obstacles}

Les obstacles apparaissent de manière pseudoaléatoire selon la formule :
\[
\text{spawn\_timer} > \frac{90}{\text{vitesse}} + \text{rand}(0, 40)
\]

En mode DIFFICILE, les obstacles sont 2× plus fréquents :
\[
\text{spawn\_timer} > \frac{45}{\text{vitesse}} + \text{rand}(0, 30)
\]

Les obstacles se divisent en trois catégories avec les dimensions suivantes :

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Type} & \textbf{Hauteur} & \textbf{Largeur} & \textbf{Couleur} \\
\hline
Voiture & Basse (1 ligne) & 2-3 caractères & ROUGE \\
Camion & Haute (3 lignes) & 4-5 caractères & BLEU \\
Policier & Moyenne (2 lignes) & 3-4 caractères & MAGENTA \\
\hline
\end{tabular}
\end{center}

\subsubsection{Système de Score}

\begin{itemize}
    \item \textbf{Distance} : +0.1 points/frame × vitesse actuelle
    \item \textbf{Bonus "Bedo"} : +50 points par collecte
    \item \textbf{Vitesse Progressive} : augmente de 0.05 toutes les 500 points
    \item \textbf{Multiplicateur Difficulté} : ×1.5 en mode DIFFICILE
\end{itemize}

\subsection{Système de Collision}

La détection de collision utilise un rectangle AABB simplifié :

\begin{lstlisting}
def rect_collision(self, autre):
    col_x = (self.x < autre.x + autre.width - 2) and \
            (self.x + self.width > autre.x + 2)
    col_y = (self.y < autre.y + autre.height) and \
            (self.y + self.height > autre.y)
    return col_x and col_y
\end{lstlisting}

Un léger offset de \texttt{-2} est appliqué pour rendre le jeu plus "jouable" (hitbox légèrement plus petite que l'affichage).

% ==================== SECTION 3 ====================
\section{Architecture Technique}

\subsection{Structure du Projet}

\begin{verbatim}
Projet Thouv\
├── src/
│   ├── main_graphique.py      # Interface Pygame (1200+ lignes)
│   ├── main_terminal.py       # Interface Curses (400+ lignes)
│   ├── moteur_jeu.py          # Logique de jeu (Classes Entité, Jeu)
│   ├── gestion_scores.py      # Sync scores + sauvegarde
│   └── tache_fond.py          # Thread de musique
├── server/
│   └── api_server.py          # API Flask + Leaderboard
├── web/
│   └── scores.html            # Leaderboard web (Pixel Art)
├── data/
│   ├── thouv_scores.json      # Scores locaux
│   └── server_scores.json     # Backup persistant
├── assets/
│   ├── images/                # Sprites, icônes
│   ├── sounds/                # Effets sonores
│   ├── music/                 # Musiques de fond
│   └── fonts/                 # Polices (Jersey10, Press Start 2P)
├── SETUP.bat                  # Installation auto (Python + pip)
├── Thouv-Run-Graphique.bat    # Lanceur Pygame
└── Thouv-Run-Terminal.bat     # Lanceur Terminal
\end{verbatim}

\subsection{Stack Technologique}

\begin{center}
\begin{tabular}{|l|c|}
\hline
\textbf{Composant} & \textbf{Technologie} \\
\hline
Langage Principal & Python 3.12 \\
Interface Graphique & Pygame 2.5.2 \\
Interface Terminal & windows-curses 2.4.1 \\
Backend Serveur & Flask 3.0.0 + Flask-CORS \\
Base de Données & JSON (SQLite éphémère en production) \\
Hébergement & Railway.app (container Docker) \\
Frontend Web & HTML5 + CSS3 + JavaScript Vanilla \\
Domaine Custom & thouvrun.com (Ionos, Railway) \\
\hline
\end{tabular}
\end{center}

\subsection{Architecture des Classes}

\subsubsection{Classe \texttt{Entite}}

Classe parent pour tous les objets du jeu (joueur, obstacles, bonus) :

\begin{lstlisting}
class Entite:
    def __init__(self, x, y, width, height, type_entite, art):
        self.x = x           # Position X (relative au viewport)
        self.y = y           # Position Y (relative au sol)
        self.width = width   # Largeur en caractères
        self.height = height # Hauteur en lignes
        self.type = type_entite  # "voiture", "camion", etc.
        self.art = art       # ASCII art pour affichage
    
    def rect_collision(self, autre):
        # Détection collision AABB
        pass
\end{lstlisting}

\subsubsection{Classe \texttt{Thouverez} (Joueur)}

Hérite de \texttt{Entite}, gère les sauts et l'état du joueur :

\begin{lstlisting}
class Thouverez(Entite):
    def __init__(self):
        super().__init__(10, SOL_ECRAN, 2, 3, "joueur", ART_JOUEUR)
        self.is_jumping = False
        self.jump_vel = 0
    
    def sauter_court(self):
        if not self.is_jumping:
            self.is_jumping = True
            self.jump_vel = -2  # Hauteur: ~3 lignes
    
    def sauter_long(self):
        if not self.is_jumping:
            self.is_jumping = True
            self.jump_vel = -3  # Hauteur: ~5 lignes
    
    def update(self):
        # Appliquer gravité et détecter sol
        pass
\end{lstlisting}

\subsubsection{Classe \texttt{Jeu}}

Moteur central gérant la physique, les collisions et le game loop :

\begin{lstlisting}
class Jeu:
    def __init__(self, nom_joueur, version_jeu, difficulte="NORMALE"):
        self.joueur = Thouverez()
        self.obstacles = []    # Liste des obstacles actifs
        self.bonus = []        # Liste des bonus actifs
        self.score = 0
        self.distance = 0
        self.bedos = 0
        self.vitesse = 1.0
        self.running = True
        self.difficulte = difficulte
    
    def update(self):
        # Appliquer physique
        # Générer obstacles
        # Vérifier collisions
        # Calculer score
        pass
    
    def fin_partie(self, cause):
        # Enregistrer score dans JSON + API
        pass
\end{lstlisting}

\subsection{Gestion des Scores et Synchronisation}

La synchronisation fonctionne en trois couches :

\begin{enumerate}
    \item \textbf{Couche Locale} : \texttt{data/thouv\_scores.json}
    \begin{itemize}
        \item Sauvegarde immédiate après chaque partie
        \item Toujours accessible, même hors-ligne
        \item Backup utilisé au démarrage du jeu
    \end{itemize}
    
    \item \textbf{Couche Serveur} : API Flask à \texttt{https://thouvrun-production.up.railway.app}
    \begin{itemize}
        \item POST \texttt{/api/scores} : envoyer un nouveau score
        \item GET \texttt{/api/scores?limit=500} : récupérer les N meilleurs scores
        \item Base de données SQLite éphémère (regénérée à chaque redémarrage)
    \end{itemize}
    
    \item \textbf{Couche Web} : Leaderboard HTML + API (actualisation 10s)
    \begin{itemize}
        \item Frontend pur (Vanilla JS, pas de framework)
        \item Récupération de 191 scores dedupliqués
        \item Tri par Points/Distance/Bedos/Date
        \item Recherche par nom de joueur
    \end{itemize}
\end{enumerate}

\subsubsection{Synchronisation Automatique du Backup}

Après chaque partie, la fonction \texttt{\_synchroniser\_backup\_depuis\_serveur()} exécutée en thread :

\begin{lstlisting}
def sauvegarder_nouveau_score(...):
    # 1. Sauvegarder localement
    scores.append(nouvelle_entree)
    with open(FICHIER_SCORES, 'w') as f:
        json.dump(scores, f)
    
    # 2. Envoyer à l'API (thread)
    _envoyer_score_api(nouvelle_entree)
    
    # 3. Télécharger TOUS les scores du serveur
    # et fusionner dans le backup local
    _synchroniser_backup_depuis_serveur()
\end{lstlisting}

Cela garantit qu'aucun score n'est perdu lors d'un déploiement ou redémarrage serveur.

% ==================== SECTION 4 ====================
\section{Choix de Conception}

\subsection{Pourquoi Python?}

\begin{tcolorbox}[colback=green!5!white, colframe=green!75!black, title=Justification]
\begin{itemize}
    \item \textbf{Rapidité de développement} : Syntaxe claire, moins de boilerplate
    \item \textbf{Écosystème} : Pygame mature pour graphisme 2D, Flask pour serveur
    \item \textbf{Cross-plateforme} : Code identique sur Windows/Linux/macOS
    \item \textbf{Flexibilité} : Facile de switcher entre GUI (Pygame) et TUI (Curses)
    \item \textbf{Prototypage} : Idéal pour game jam et projets académiques
\end{itemize}
\end{tcolorbox}

\subsection{Architecture Monolithique vs Microservices}

\textbf{Choix : Monolithique avec séparation concerns}

\begin{itemize}
    \item Chaque module a une responsabilité unique
    \item \texttt{moteur\_jeu.py} : Logique pure, pas de GUI
    \item \texttt{main\_graphique.py} / \texttt{main\_terminal.py} : Couches présentation
    \item \texttt{gestion\_scores.py} : Logique métier (persistance)
    \item Facile à tester en isolé
\end{itemize}

\subsection{Interface Unique vs Multiples}

\textbf{Choix : Deux interfaces}

\begin{itemize}
    \item \textbf{Pygame (Graphique)} : Moderne, accès grand public
    \item \textbf{Curses (Terminal)} : Rétro, hommage aux jeux 80s-90s
    \item Partagent la même logique de jeu (\texttt{moteur\_jeu.py})
    \item Minimise duplication, permet expérimentation UI
\end{itemize}

\subsection{Stockage : JSON vs Base de Données}

\textbf{Choix : JSON pour local, SQLite en production}

\begin{itemize}
    \item \textbf{Local (JSON)} : Zéro dépendance, fichier texte, versionnage Git facile
    \item \textbf{Serveur (SQLite)} : Léger, intégré à Python, suffisant pour 191 scores
    \item Pas besoin de MySQL/PostgreSQL pour ce cas d'usage
    \item Les scores sont sauvegardés dans Git → backup automatique
\end{itemize}

\subsection{Déploiement : Railway.app}

\textbf{Choix : Conteneur Docker sur Railway}

\begin{itemize}
    \item Déploiement simple : \texttt{git push} déclenche build + deploy
    \item Certificat SSL automatique
    \item Scaling gratuit pour petit trafic
    \item Alternative : Heroku (fermé), Replit, PythonAnywhere
\end{itemize}

% ==================== SECTION 5 ====================
\section{Processus de Développement}

\subsection{Phases du Projet}

\begin{center}
\begin{tabular}{|l|p{6cm}|l|}
\hline
\textbf{Phase} & \textbf{Objectifs} & \textbf{Durée} \\
\hline
1. Prototype & Logique jeu + première interface & 2-3 jours \\
2. Polissage & Graphisme, son, UI & 1-2 jours \\
3. Sync Scores & API, leaderboard, stockage & 2-3 jours \\
4. Déploiement & Railway, domaine, optimisations & 1-2 jours \\
5. Bug Fixes & Alignement tableau, backup sync & 1 jour \\
\hline
\end{tabular}
\end{center}

\subsection{Itérations Principales}

\subsubsection{Animation du Fond}

\textbf{Problème} : Les weeds (mauvaises herbes) du fond n'animaient pas correctement.

\textbf{Solution} : Après 8 tentatives, implémentation d'une animation diagonale en CSS :

\begin{lstlisting}[language=CSS]
@keyframes weedsDiagonal {
    0% { background-position: 0 0; }
    100% { background-position: 200px -200px; }
}
animation: weedsDiagonal 6s linear infinite;
\end{lstlisting}

\textbf{Apprentissage clé} : En CSS, \texttt{background-position: X Y} où X positif = droite, Y négatif = haut.

\subsubsection{Responsive Design}

\textbf{Problème} : Le leaderboard n'était pas lisible sur mobile/tablet.

\textbf{Solution} : Media queries multiples avec colonnes adaptées :

\begin{itemize}
    \item Desktop : 6 colonnes à 80px/1fr/120px/120px/120px/140px
    \item Tablet (768px) : Réduction à 50px/1fr/100px/120px/120px/130px
    \item Mobile (480px) : Scroll horizontal avec hint "(← glisse →)"
    \item Very small (320px) : Nouvelles réductions
\end{itemize}

\subsubsection{Perte de Données}

\textbf{Problème} : À chaque \texttt{git push}, les scores joués localement étaient perdus.

\textbf{Solution} : Fonction \texttt{\_synchroniser\_backup\_depuis\_serveur()} qui télécharge les scores du serveur après chaque partie et les fusionne avec le backup local.

\textbf{Impact} : Zéro perte de données, même lors de déploiements.

\subsection{Gestion des Défauts}

\begin{center}
\begin{tabular}{|p{3cm}|p{4cm}|p{3cm}|}
\hline
\textbf{Défaut} & \textbf{Cause Racine} & \textbf{Correction} \\
\hline
Favicon ne s'affiche pas & Cache navigateur & Ajout \texttt{?v=1} \\
Date mal triée & Format DD/MM/YYYY interprété comme texte & Parser JS personnalisé \\
Colonnes misalignées & CSS dupliqué et conflictuel & Consolidation CSS \\
Doublons leaderboard & Scores importés plusieurs fois & Clé composite (nom, score, date) \\
\hline
\end{tabular}
\end{center}

% ==================== SECTION 6 ====================
\section{Résultats et Performances}

\subsection{Métriques du Leaderboard}

\begin{itemize}
    \item \textbf{Scores actifs} : 191 entrées uniques (après déduplication)
    \item \textbf{Joueurs distincts} : ~45-50
    \item \textbf{Meilleur score} : 751 points (401 mètres, 7 bedos)
    \item \textbf{Temps de chargement} : <500ms (API + parse JSON)
\end{itemize}

\subsection{Performance Moteur Jeu}

\begin{itemize}
    \item \textbf{FPS cible} : 60 (60 ms/frame)
    \item \textbf{FPS réel} : 55-60 sur hardware modéré
    \item \textbf{Mémoire} : ~80-120 MB (Pygame + assets)
    \item \textbf{Startup} : ~2-3 secondes (chargement assets + sync)
\end{itemize}

\subsection{Uptime Serveur}

\begin{itemize}
    \item \textbf{Disponibilité} : 99.5% (Railway SLA)
    \item \textbf{Response time API} : <100ms en moyenne
    \item \textbf{Leaderboard} : Actualisation 10 secondes
\end{itemize}

% ==================== SECTION 7 ====================
\section{Améliorations Futures}

\subsection{Échelle Court Terme}

\begin{itemize}
    \item[] Power-ups : Invincibilité, ralentissement temps
    \item[] Skins personnalisables pour le joueur
    \item[] Achievements et badges
    \item[] Mode multijoueur local (splitscreen)
\end{itemize}

\subsection{Échelle Moyen Terme}

\begin{itemize}
    \item[] Application mobile (Flutter/React Native)
    \item[] Matchmaking en ligne (1v1)
    \item[] Boutique cosmétique ($\$$)
    \item[] Replay/Spectate system
\end{itemize}

\subsection{Échelle Long Terme}

\begin{itemize}
    \item[] Engine personnalisé (Godot/Unreal)
    \item[] Campagne histoire
    \item[] Éditeur de niveaux utilisateur
    \item[] Intégration Steam
\end{itemize}

% ==================== SECTION 8 ====================
\section{Conclusion}

Thouv'Run démontre comment construire un jeu complet avec :
\begin{itemize}
    \item Architecture modulaire et testable (séparation logique/UI)
    \item Déploiement production avec synchronisation robuste
    \item Interface responsive multi-plateforme
    \item Pipeline de développement itératif (Git, Railway)
\end{itemize}

Le projet illustre les bonnes pratiques du développement jeu indie :
\begin{itemize}
    \item ✓ Scope limité et réalisable
    \item ✓ Itérations rapides et feedback utilisateur
    \item ✓ Passion + polish (pixel art, musique)
    \item ✓ Code propre et maintenable
\end{itemize}

\vfill

\begin{center}
\textit{« Un jeu simple, mais bien fait. Voilà Thouv'Run! »}
\end{center}

\end{document}
